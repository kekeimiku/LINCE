#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused)]

// 由bindgen自动生成并手动略微修改

// #include <libproc.h>
// #include <mach/task_info.h>
// #include <mach-o/dyld_images.h>
// #include <mach-o/loader.h>
// #include <mach/mach_vm.h>
// #include <mach/mach_traps.h>
// #include <mach/kern_return.h>
// #include <mach/vm_prot.h>

// let bindings = bindgen::builder()
//         .header("wrapper.h")
//         .use_core()
//         // .default_macro_constant_type(bindgen::MacroTypeVariation::Signed)
//         .layout_tests(false)
//         .allowlist_type("dyld_all_image_infos")
//         .allowlist_type("dyld_image_info")
//         .allowlist_type("kern_return_t")
//         .allowlist_type("mach_header_64")
//         .allowlist_type("task_dyld_info")
//         .allowlist_type("dyld_image_notifier")
//         .allowlist_type("mach_vm_address_t")
//         .allowlist_type("mach_vm_size_t")
//         .allowlist_type("segment_command_64")
//         .allowlist_type("vm_region_extended_info")
//         .allowlist_type("vm_region_extended_info_data_t")
//         .allowlist_type("vm_region_info_t")
//         .allowlist_type("vm_task_entry_t")
//         .allowlist_function("task_for_pid")
//         .allowlist_function("mach_vm_region")
//         .allowlist_function("task_info")
//         .allowlist_function("mach_vm_read_overwrite")
//         .allowlist_function("mach_vm_write")
//         .allowlist_function("proc_regionfilename")
//         .allowlist_function("proc_pidpath")
//         .allowlist_var("mach_task_self_")
//         .allowlist_var("MACH_PORT_NULL")
//         .allowlist_var("KERN_SUCCESS")
//         .allowlist_var("VM_REGION_EXTENDED_INFO")
//         .allowlist_var("PROC_PIDPATHINFO_MAXSIZE")
//         .allowlist_var("TASK_DYLD_INFO")
//         // .allowlist_var("VM_PROT_READ")
//         // .allowlist_var("VM_PROT_WRITE")
//         // .allowlist_var("VM_PROT_EXECUTE")
//         .generate_inline_functions(true)
//         .generate()
//         .expect("Unable to generate bindings");

/* automatically generated by rust-bindgen 0.63.0 */

pub const MACH_PORT_NULL: u32 = 0;
pub const KERN_SUCCESS: i32 = 0;
pub const PROC_PIDPATHINFO_MAXSIZE: u32 = 4096;
pub const TASK_DYLD_INFO: u32 = 17;
pub const VM_REGION_EXTENDED_INFO: i32 = 13;
pub type __darwin_natural_t = ::core::ffi::c_uint;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_uuid_t = [::core::ffi::c_uchar; 16usize];
pub type natural_t = __darwin_natural_t;
pub type integer_t = ::core::ffi::c_int;
pub type vm_offset_t = usize;
pub type mach_vm_address_t = u64;
pub type mach_vm_size_t = u64;
pub type mach_port_name_t = natural_t;
pub type mach_port_t = __darwin_mach_port_t;
pub type kern_return_t = ::core::ffi::c_int;
pub type mach_msg_type_number_t = natural_t;
pub type uuid_t = __darwin_uuid_t;
extern "C" {
    pub fn proc_regionfilename(
        pid: ::core::ffi::c_int,
        address: u64,
        buffer: *mut ::core::ffi::c_void,
        buffersize: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn proc_pidpath(
        pid: ::core::ffi::c_int,
        buffer: *mut ::core::ffi::c_void,
        buffersize: u32,
    ) -> ::core::ffi::c_int;
}
pub type vm_map_t = mach_port_t;
pub type vm_map_read_t = mach_port_t;
pub type task_flavor_t = natural_t;
pub type task_info_t = *mut integer_t;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct task_dyld_info {
    pub all_image_info_addr: mach_vm_address_t,
    pub all_image_info_size: mach_vm_size_t,
    pub all_image_info_format: integer_t,
}
pub type vm_prot_t = ::core::ffi::c_int;
pub type vm_region_info_t = *mut ::core::ffi::c_int;
pub type vm_region_flavor_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_region_extended_info {
    pub protection: vm_prot_t,
    pub user_tag: ::core::ffi::c_uint,
    pub pages_resident: ::core::ffi::c_uint,
    pub pages_shared_now_private: ::core::ffi::c_uint,
    pub pages_swapped_out: ::core::ffi::c_uint,
    pub pages_dirtied: ::core::ffi::c_uint,
    pub ref_count: ::core::ffi::c_uint,
    pub shadow_depth: ::core::ffi::c_ushort,
    pub external_pager: ::core::ffi::c_uchar,
    pub share_mode: ::core::ffi::c_uchar,
    pub pages_reusable: ::core::ffi::c_uint,
}
pub type vm_region_extended_info_data_t = vm_region_extended_info;
pub type task_name_t = mach_port_t;
pub type vm_task_entry_t = mach_port_t;
extern "C" {
    pub fn task_info(
        target_task: task_name_t,
        flavor: task_flavor_t,
        task_info_out: task_info_t,
        task_info_outCnt: *mut mach_msg_type_number_t,
    ) -> kern_return_t;
}
extern "C" {
    pub static mut mach_task_self_: mach_port_t;
}
extern "C" {
    pub fn task_for_pid(
        target_tport: mach_port_name_t,
        pid: ::core::ffi::c_int,
        t: *mut mach_port_name_t,
    ) -> kern_return_t;
}
pub const dyld_image_mode_dyld_image_adding: dyld_image_mode = 0;
pub const dyld_image_mode_dyld_image_removing: dyld_image_mode = 1;
pub const dyld_image_mode_dyld_image_info_change: dyld_image_mode = 2;
pub const dyld_image_mode_dyld_image_dyld_moved: dyld_image_mode = 3;
pub type dyld_image_mode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dyld_image_info {
    pub imageLoadAddress: *const mach_header,
    pub imageFilePath: *const ::core::ffi::c_char,
    pub imageFileModDate: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dyld_uuid_info {
    pub imageLoadAddress: *const mach_header,
    pub imageUUID: uuid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dyld_aot_image_info {
    pub x86LoadAddress: *const mach_header,
    pub aotLoadAddress: *const mach_header,
    pub aotImageSize: u64,
    pub aotImageKey: [u8; 32usize],
}
pub type dyld_image_notifier = ::core::option::Option<
    unsafe extern "C" fn(mode: dyld_image_mode, infoCount: u32, info: *const dyld_image_info),
>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct dyld_all_image_infos {
    pub version: u32,
    pub infoArrayCount: u32,
    pub infoArray: *const dyld_image_info,
    pub notification: dyld_image_notifier,
    pub processDetachedFromSharedRegion: bool,
    pub libSystemInitialized: bool,
    pub dyldImageLoadAddress: *const mach_header,
    pub jitInfo: *mut ::core::ffi::c_void,
    pub dyldVersion: *const ::core::ffi::c_char,
    pub errorMessage: *const ::core::ffi::c_char,
    pub terminationFlags: usize,
    pub coreSymbolicationShmPage: *mut ::core::ffi::c_void,
    pub systemOrderFlag: usize,
    pub uuidArrayCount: usize,
    pub uuidArray: *const dyld_uuid_info,
    pub dyldAllImageInfosAddress: *mut dyld_all_image_infos,
    pub initialImageCount: usize,
    pub errorKind: usize,
    pub errorClientOfDylibPath: *const ::core::ffi::c_char,
    pub errorTargetDylibPath: *const ::core::ffi::c_char,
    pub errorSymbol: *const ::core::ffi::c_char,
    pub sharedCacheSlide: usize,
    pub sharedCacheUUID: [u8; 16usize],
    pub sharedCacheBaseAddress: usize,
    pub infoArrayChangeTimestamp: u64,
    pub dyldPath: *const ::core::ffi::c_char,
    pub notifyPorts: [mach_port_t; 8usize],
    pub reserved: [usize; 7usize],
    pub sharedCacheFSID: u64,
    pub sharedCacheFSObjID: u64,
    pub compact_dyld_image_info_addr: usize,
    pub compact_dyld_image_info_size: usize,
    pub platform: u32,
    pub aotInfoCount: u32,
    pub aotInfoArray: *const dyld_aot_image_info,
    pub aotInfoArrayChangeTimestamp: u64,
    pub aotSharedCacheBaseAddress: usize,
    pub aotSharedCacheUUID: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_header {
    pub magic: u32,
    pub cputype: i32,
    pub cpusubtype: i32,
    pub filetype: u32,
    pub ncmds: u32,
    pub sizeofcmds: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_header_64 {
    pub magic: u32,
    pub cputype: i32,
    pub cpusubtype: i32,
    pub filetype: u32,
    pub ncmds: u32,
    pub sizeofcmds: u32,
    pub flags: u32,
    pub reserved: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct segment_command_64 {
    pub cmd: u32,
    pub cmdsize: u32,
    pub segname: [::core::ffi::c_char; 16usize],
    pub vmaddr: u64,
    pub vmsize: u64,
    pub fileoff: u64,
    pub filesize: u64,
    pub maxprot: i32,
    pub initprot: i32,
    pub nsects: u32,
    pub flags: u32,
}
extern "C" {
    pub fn mach_vm_write(
        target_task: vm_map_t,
        address: mach_vm_address_t,
        data: vm_offset_t,
        dataCnt: mach_msg_type_number_t,
    ) -> kern_return_t;
}
extern "C" {
    pub fn mach_vm_read_overwrite(
        target_task: vm_map_read_t,
        address: mach_vm_address_t,
        size: mach_vm_size_t,
        data: mach_vm_address_t,
        outsize: *mut mach_vm_size_t,
    ) -> kern_return_t;
}
extern "C" {
    pub fn mach_vm_region(
        target_task: vm_map_read_t,
        address: *mut mach_vm_address_t,
        size: *mut mach_vm_size_t,
        flavor: vm_region_flavor_t,
        info: vm_region_info_t,
        infoCnt: *mut mach_msg_type_number_t,
        object_name: *mut mach_port_t,
    ) -> kern_return_t;
}

// `mach/vm_prot.h`
pub const VM_PROT_NONE: vm_prot_t = 0;
pub const VM_PROT_READ: vm_prot_t = 1;
pub const VM_PROT_WRITE: vm_prot_t = 1 << 1;
pub const VM_PROT_EXECUTE: vm_prot_t = 1 << 2;
pub const VM_PROT_NO_CHANGE: vm_prot_t = 1 << 3;
pub const VM_PROT_COPY: vm_prot_t = 1 << 4;
pub const VM_PROT_WANTS_COPY: vm_prot_t = 1 << 4;
pub const VM_PROT_DEFAULT: vm_prot_t = VM_PROT_READ | VM_PROT_WRITE;
pub const VM_PROT_ALL: vm_prot_t = VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
